<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>python_pachyderm API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>python_pachyderm</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import string as _string
import importlib as _importlib
import enum as _enum
from google.protobuf.internal.enum_type_wrapper import (
    EnumTypeWrapper as _EnumTypeWrapper,
)

from .mixin.pfs import PFSFile, ModifyFileClient
from .client import Client, ConfigError, BadClusterDeploymentID
from .spout import SpoutManager, SpoutCommit
from .util import (
    put_files,
    parse_json_pipeline_spec,
    parse_dict_pipeline_spec,
)
from grpc import RpcError


__pdoc__ = {&#34;proto&#34;: False}


__all__ = [
    &#34;Client&#34;,
    &#34;RpcError&#34;,
    &#34;SpoutManager&#34;,
    &#34;SpoutCommit&#34;,
    &#34;put_files&#34;,
    &#34;PFSFile&#34;,
    &#34;ModifyFileClient&#34;,
    &#34;parse_json_pipeline_spec&#34;,
    &#34;parse_dict_pipeline_spec&#34;,
    &#34;ConfigError&#34;,
    &#34;BadClusterDeploymentID&#34;,
]


try:
    from .version import __version__

    __version__ = __version__
except ModuleNotFoundError:
    # The version module is dynamically generated at install time, so if
    # referencing python-pachyderm without having installed it, the import
    # will fail -- so we just ignore import failures here.
    pass
else:
    __all__.append(&#34;__version__&#34;)


def _import_protos(path):
    &#34;&#34;&#34;
    Imports items selectively from the auto-generated proto package.

    Importing is done dynamically so we can selectively blacklist items. We
    also dynamically define enums that build on top of the auto-generated
    protobuf enums, to create a more pythonic API.

    More broadly, the dark magic in here allows us to maintain parity with
    Pachyderm protobufs when they change, without having to maintain a manual
    mapping of protobuf to python_pachyderm values.
    &#34;&#34;&#34;

    g = globals()
    module = _importlib.import_module(path)
    uppercase_letters = set(_string.ascii_uppercase)
    lowercase_letters = set(_string.ascii_lowercase)

    def import_item(g, module, key):
        value = getattr(module, key)

        if isinstance(value, _EnumTypeWrapper):
            # Dynamically define an enum class that is exported
            g[key] = _enum.Enum(key, {k: v for (k, v) in value.items()})
        else:
            # Export the value
            g[key] = value

        __all__.append(key)

    def should_import(key):
        return key[0] in uppercase_letters and any(
            c in lowercase_letters for c in key[1:]
        )

    for key in dir(module):
        if should_import(key):
            import_item(g, module, key)
        elif key.startswith(&#34;google_dot_protobuf_dot_&#34;):
            sub_module = getattr(module, key)
            for key in dir(sub_module):
                if should_import(key):
                    import_item(g, sub_module, key)


# _import_protos(&#34;python_pachyderm.proto.v2.pfs.pfs_pb2&#34;)
# _import_protos(&#34;python_pachyderm.proto.v2.pps.pps_pb2&#34;)
# _import_protos(&#34;python_pachyderm.proto.v2.version.versionpb.version_pb2&#34;)
# _import_protos(&#34;python_pachyderm.proto.v2.transaction.transaction_pb2&#34;)
# _import_protos(&#34;python_pachyderm.proto.v2.admin.admin_pb2&#34;)
# _import_protos(&#34;python_pachyderm.proto.v2.auth.auth_pb2&#34;)
# _import_protos(&#34;python_pachyderm.proto.v2.enterprise.enterprise_pb2&#34;)
# _import_protos(&#34;python_pachyderm.proto.v2.license.license_pb2&#34;)
# _import_protos(&#34;python_pachyderm.proto.v2.identity.identity_pb2&#34;)</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="python_pachyderm.client" href="client.html">python_pachyderm.client</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="python_pachyderm.mixin" href="mixin/index.html">python_pachyderm.mixin</a></code></dt>
<dd>
<div class="desc"><p>Exposes a mixin for each pachyderm service. These mixins should not be used
directly; instead, you should use <code><a title="python_pachyderm.Client" href="#python_pachyderm.Client">Client</a></code>. The mixins â€¦</p></div>
</dd>
<dt><code class="name"><a title="python_pachyderm.service" href="service.html">python_pachyderm.service</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="python_pachyderm.spout" href="spout.html">python_pachyderm.spout</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="python_pachyderm.util" href="util.html">python_pachyderm.util</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="python_pachyderm.version" href="version.html">python_pachyderm.version</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="python_pachyderm.parse_dict_pipeline_spec"><code class="name flex">
<span>def <span class="ident">parse_dict_pipeline_spec</span></span>(<span>d)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses a dict of serialized JSON into a <code>CreatePipelineRequest</code> protobuf.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_dict_pipeline_spec(d):
    &#34;&#34;&#34;
    Parses a dict of serialized JSON into a `CreatePipelineRequest` protobuf.
    &#34;&#34;&#34;
    return json_format.ParseDict(d, CreatePipelineRequest())</code></pre>
</details>
</dd>
<dt id="python_pachyderm.parse_json_pipeline_spec"><code class="name flex">
<span>def <span class="ident">parse_json_pipeline_spec</span></span>(<span>j)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses a string of JSON into a <code>CreatePipelineRequest</code> protobuf.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_json_pipeline_spec(j):
    &#34;&#34;&#34;
    Parses a string of JSON into a `CreatePipelineRequest` protobuf.
    &#34;&#34;&#34;
    return json_format.Parse(j, CreatePipelineRequest())</code></pre>
</details>
</dd>
<dt id="python_pachyderm.put_files"><code class="name flex">
<span>def <span class="ident">put_files</span></span>(<span>client:Â <a title="python_pachyderm.client.Client" href="client.html#python_pachyderm.client.Client">Client</a>, source_path, commit, dest_path, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Utility function for recursively inserting files from the local
<code>source_path</code> to pachyderm. Roughly equivalent to <code>pachctl put file -r</code>.</p>
<p>Params:</p>
<ul>
<li><code><a title="python_pachyderm.client" href="client.html">python_pachyderm.client</a></code>: The <code><a title="python_pachyderm.Client" href="#python_pachyderm.Client">Client</a></code> instance to use.</li>
<li><code>source_path</code>: The directory to recursively insert content from.</li>
<li><code>commit</code>: The <code>Commit</code> object to use for inserting files.</li>
<li><code>dest_path</code>: The destination path in PFS.</li>
<li><code>kwargs</code>: Keyword arguments to forward. See
<code>PutFileClient.put_file_from_fileobj</code> for details.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_files(client: Client, source_path, commit, dest_path, **kwargs):
    &#34;&#34;&#34;
    Utility function for recursively inserting files from the local
    `source_path` to pachyderm. Roughly equivalent to `pachctl put file -r`.

    Params:

    * `client`: The `Client` instance to use.
    * `source_path`: The directory to recursively insert content from.
    * `commit`: The `Commit` object to use for inserting files.
    * `dest_path`: The destination path in PFS.
    * `kwargs`: Keyword arguments to forward. See
    `PutFileClient.put_file_from_fileobj` for details.
    &#34;&#34;&#34;

    with client.modify_file_client(commit) as pfc:
        for root, _, filenames in os.walk(source_path):
            for filename in filenames:
                source_filepath = os.path.join(root, filename)
                dest_filepath = os.path.join(
                    dest_path, os.path.relpath(source_filepath, start=source_path)
                )
                pfc.put_file_from_filepath(dest_filepath, source_filepath, **kwargs)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="python_pachyderm.BadClusterDeploymentID"><code class="flex name class">
<span>class <span class="ident">BadClusterDeploymentID</span></span>
<span>(</span><span>expected_deployment_id, actual_deployment_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Error triggered when connected to a cluster that reports back a different
cluster deployment ID than what is stored in the config file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BadClusterDeploymentID(ConfigError):
    &#34;&#34;&#34;
    Error triggered when connected to a cluster that reports back a different
    cluster deployment ID than what is stored in the config file
    &#34;&#34;&#34;

    def __init__(self, expected_deployment_id, actual_deployment_id):
        super().__init__(
            &#34;connected to the wrong cluster (&#39;{}&#39; vs &#39;{}&#39;)&#34;.format(
                expected_deployment_id, actual_deployment_id
            )
        )
        self.expected_deployment_id = expected_deployment_id
        self.actual_deployment_id = actual_deployment_id</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="python_pachyderm.client.ConfigError" href="client.html#python_pachyderm.client.ConfigError">ConfigError</a></li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="python_pachyderm.Client"><code class="flex name class">
<span>class <span class="ident">Client</span></span>
<span>(</span><span>host=None, port=None, auth_token=None, root_certs=None, transaction_id=None, tls=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a Pachyderm client.</p>
<p>Params:</p>
<ul>
<li><code>host</code>: The pachd host. Default is 'localhost', which is used with
<code>pachctl port-forward</code>.</li>
<li><code>port</code>: The port to connect to. Default is 30650.</li>
<li><code>auth_token</code>: The authentication token; used if authentication is
enabled on the cluster. Defaults to <code>None</code>.</li>
<li><code>root_certs</code>:
The PEM-encoded root certificates as byte string.</li>
<li><code>transaction_id</code>: The ID of the transaction to run operations on.</li>
<li><code>tls</code>: Specifies whether TLS should be used. If <code>root_certs</code> are
specified, they are used; otherwise, we use the certs provided by
certifi.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Client(
    AdminMixin,
    AuthMixin,
    DebugMixin,
    EnterpriseMixin,
    HealthMixin,
    IdentityMixin,
    LicenseMixin,
    PFSMixin,
    PPSMixin,
    TransactionMixin,
    VersionMixin,
    object,
):
    def __init__(
        self,
        host=None,
        port=None,
        auth_token=None,
        root_certs=None,
        transaction_id=None,
        tls=None,
    ):
        &#34;&#34;&#34;
        Creates a Pachyderm client.

        Params:

        * `host`: The pachd host. Default is &#39;localhost&#39;, which is used with
        `pachctl port-forward`.
        * `port`: The port to connect to. Default is 30650.
        * `auth_token`: The authentication token; used if authentication is
        enabled on the cluster. Defaults to `None`.
        * `root_certs`:  The PEM-encoded root certificates as byte string.
        * `transaction_id`: The ID of the transaction to run operations on.
        * `tls`: Specifies whether TLS should be used. If `root_certs` are
        specified, they are used; otherwise, we use the certs provided by
        certifi.
        &#34;&#34;&#34;

        host = host or &#34;localhost&#34;
        port = port or 30650

        if auth_token is None:
            auth_token = os.environ.get(&#34;PACH_PYTHON_AUTH_TOKEN&#34;)

        if tls is None:
            tls = root_certs is not None
        if tls and root_certs is None:
            # load default certs if none are specified
            import certifi

            with open(certifi.where(), &#34;rb&#34;) as f:
                root_certs = f.read()

        self.address = &#34;{}:{}&#34;.format(host, port)
        self.root_certs = root_certs
        self._stubs = {}
        self._auth_token = auth_token
        self._transaction_id = transaction_id
        self._metadata = self._build_metadata()
        if not auth_token and os.environ.get(&#34;PACH_PYTHON_OIDC_TOKEN&#34;):
            resp = self.authenticate_id_token(os.environ.get(&#34;PACH_PYTHON_OIDC_TOKEN&#34;))
            self._auth_token = resp
            self._metadata = self._build_metadata()

    @classmethod
    def new_in_cluster(cls, auth_token=None, transaction_id=None):
        &#34;&#34;&#34;
        Creates a Pachyderm client that operates within a Pachyderm cluster.

        Params:

        * `auth_token`: The authentication token; used if authentication is
        enabled on the cluster. Default to `None`.
        * `transaction_id`: The ID of the transaction to run operations on.
        &#34;&#34;&#34;

        if (
            &#34;PACHD_PEER_SERVICE_HOST&#34; in os.environ
            and &#34;PACHD_PEER_SERVICE_PORT&#34; in os.environ
        ):
            # Try to use the pachd peer service if it&#39;s available. This is
            # only supported in pachyderm&gt;=1.10, but is more reliable because
            # it&#39;ll work when TLS is enabled on the cluster.
            host = os.environ[&#34;PACHD_PEER_SERVICE_HOST&#34;]
            port = int(os.environ[&#34;PACHD_PEER_SERVICE_PORT&#34;])
        else:
            # Otherwise use the normal service host/port, which will not work
            # when TLS is enabled on the cluster.
            host = os.environ[&#34;PACHD_SERVICE_HOST&#34;]
            port = int(os.environ[&#34;PACHD_SERVICE_PORT&#34;])

        return cls(
            host=host, port=port, auth_token=auth_token, transaction_id=transaction_id
        )

    @classmethod
    def new_from_pachd_address(
        cls, pachd_address, auth_token=None, root_certs=None, transaction_id=None
    ):
        &#34;&#34;&#34;
        Creates a Pachyderm client from a given pachd address.

        Params:

        * `auth_token`: The authentication token; used if authentication is
        enabled on the cluster. Default to `None`.
        * `root_certs`: The PEM-encoded root certificates as byte string. If
        unspecified, this will load default certs from certifi.
        * `transaction_id`: The ID of the transaction to run operations on.
        &#34;&#34;&#34;

        if &#34;://&#34; not in pachd_address:
            pachd_address = &#34;grpc://{}&#34;.format(pachd_address)

        u = urlparse(pachd_address)

        if u.scheme not in (&#34;grpc&#34;, &#34;http&#34;, &#34;grpcs&#34;, &#34;https&#34;):
            raise ValueError(&#34;unrecognized pachd address scheme: {}&#34;.format(u.scheme))
        if u.path != &#34;&#34; or u.params != &#34;&#34; or u.query != &#34;&#34; or u.fragment != &#34;&#34;:
            raise ValueError(&#34;invalid pachd address&#34;)
        if u.username is not None or u.password is not None:
            raise ValueError(&#34;invalid pachd address&#34;)

        return cls(
            host=u.hostname,
            port=u.port,
            auth_token=auth_token,
            root_certs=root_certs,
            transaction_id=transaction_id,
            tls=u.scheme == &#34;grpcs&#34; or u.scheme == &#34;https&#34;,
        )

    @classmethod
    def new_from_config(cls, config_file=None):
        &#34;&#34;&#34;
        Creates a Pachyderm client from a config file, which can either be
        passed in as a file-like object, or if unset, checks the PACH_CONFIG env
        var for a path. If that&#39;s also unset, it defaults to loading from
        &#39;~/.pachyderm/config.json&#39;.

        Params:

        * `config_file`: An optional file-like object containing the config
        json file. If unspecified, we load the config from the default
        location (&#39;~/.pachyderm/config.json&#39;.)
        &#34;&#34;&#34;

        if config_file is not None:
            j = json.load(config_file)
        elif &#34;PACH_CONFIG&#34; in os.environ:
            with open(os.environ.get(&#34;PACH_CONFIG&#34;), &#34;r&#34;) as config_file:
                j = json.load(config_file)
                print(&#34;config: {}&#34;.format(str(j)))
        else:
            try:
                # Search for config file in default home location
                with open(
                    str(Path.home() / &#34;.pachyderm/config.json&#34;), &#34;r&#34;
                ) as config_file:
                    j = json.load(config_file)
            except FileNotFoundError:
                # If not found, search in &#34;/pachctl&#34; (default mount for spout)
                with open(&#34;/pachctl/config.json&#34;, &#34;r&#34;) as config_file:
                    j = json.load(config_file)

        try:
            active_context = j[&#34;v2&#34;][&#34;active_context&#34;]
        except KeyError:
            raise ConfigError(&#34;no active context&#34;)

        try:
            context = j[&#34;v2&#34;][&#34;contexts&#34;][active_context]
        except KeyError:
            raise ConfigError(&#34;missing active context &#39;{}&#39;&#34;.format(active_context))

        auth_token = context.get(&#34;session_token&#34;)
        root_certs = context.get(&#34;server_cas&#34;)
        transaction_id = context.get(&#34;active_transaction&#34;)

        pachd_address = context.get(&#34;pachd_address&#34;)
        if pachd_address:
            client = cls.new_from_pachd_address(
                pachd_address,
                auth_token=auth_token,
                root_certs=root_certs,
                transaction_id=transaction_id,
            )
        else:
            port_forwarders = context.get(&#34;port_forwarders&#34;, {})
            pachd_port = port_forwarders.get(&#34;pachd&#34;, 30650)
            pachd_address = &#34;grpc://localhost:{}&#34;.format(pachd_port)
            client = cls.new_from_pachd_address(
                pachd_address, auth_token=auth_token, transaction_id=transaction_id
            )

        expected_deployment_id = context.get(&#34;cluster_deployment_id&#34;)
        if expected_deployment_id:
            cluster_info = client.inspect_cluster()
            if cluster_info.deployment_id != expected_deployment_id:
                raise BadClusterDeploymentID(
                    expected_deployment_id, cluster_info.deployment_id
                )

        return client

    @property
    def auth_token(self):
        return self._auth_token

    @auth_token.setter
    def auth_token(self, value):
        self._auth_token = value
        self._metadata = self._build_metadata()

    @property
    def transaction_id(self):
        return self._transaction_id

    @transaction_id.setter
    def transaction_id(self, value):
        self._transaction_id = value
        self._metadata = self._build_metadata()

    def _build_metadata(self):
        metadata = []
        if self._auth_token is not None:
            metadata.append((&#34;authn-token&#34;, self._auth_token))
        if self._transaction_id is not None:
            metadata.append((&#34;pach-transaction&#34;, self._transaction_id))
        return metadata

    def _req(self, grpc_service: Service, grpc_method_name, req=None, **kwargs):
        stub = self._stubs.get(grpc_service)
        if stub is None:
            grpc_module = grpc_service.grpc_module
            if self.root_certs:
                ssl_channel_credentials = grpc_module.grpc.ssl_channel_credentials
                ssl = ssl_channel_credentials(root_certificates=self.root_certs)
                channel = grpc_module.grpc.secure_channel(
                    self.address,
                    ssl,
                    options=grpc_service.options,
                )
            else:
                channel = grpc_module.grpc.insecure_channel(
                    self.address,
                    options=grpc_service.options,
                )
            stub = grpc_service.stub(channel)
            self._stubs[grpc_service] = stub

        assert req is None or len(kwargs) == 0
        assert self._metadata is not None

        if req is None:
            proto_module = grpc_service.proto_module
            if grpc_method_name.endswith(&#34;Stream&#34;):
                req_cls_name_prefix = grpc_method_name[:-6]
            else:
                req_cls_name_prefix = grpc_method_name
            req_cls = getattr(proto_module, &#34;{}Request&#34;.format(req_cls_name_prefix))
            req = req_cls(**kwargs)

        grpc_method = getattr(stub, grpc_method_name)
        return grpc_method(req, metadata=self._metadata)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="python_pachyderm.mixin.admin.AdminMixin" href="mixin/admin.html#python_pachyderm.mixin.admin.AdminMixin">AdminMixin</a></li>
<li><a title="python_pachyderm.mixin.auth.AuthMixin" href="mixin/auth.html#python_pachyderm.mixin.auth.AuthMixin">AuthMixin</a></li>
<li><a title="python_pachyderm.mixin.debug.DebugMixin" href="mixin/debug.html#python_pachyderm.mixin.debug.DebugMixin">DebugMixin</a></li>
<li><a title="python_pachyderm.mixin.enterprise.EnterpriseMixin" href="mixin/enterprise.html#python_pachyderm.mixin.enterprise.EnterpriseMixin">EnterpriseMixin</a></li>
<li><a title="python_pachyderm.mixin.health.HealthMixin" href="mixin/health.html#python_pachyderm.mixin.health.HealthMixin">HealthMixin</a></li>
<li><a title="python_pachyderm.mixin.identity.IdentityMixin" href="mixin/identity.html#python_pachyderm.mixin.identity.IdentityMixin">IdentityMixin</a></li>
<li><a title="python_pachyderm.mixin.license.LicenseMixin" href="mixin/license.html#python_pachyderm.mixin.license.LicenseMixin">LicenseMixin</a></li>
<li><a title="python_pachyderm.mixin.pfs.PFSMixin" href="mixin/pfs.html#python_pachyderm.mixin.pfs.PFSMixin">PFSMixin</a></li>
<li><a title="python_pachyderm.mixin.pps.PPSMixin" href="mixin/pps.html#python_pachyderm.mixin.pps.PPSMixin">PPSMixin</a></li>
<li><a title="python_pachyderm.mixin.transaction.TransactionMixin" href="mixin/transaction.html#python_pachyderm.mixin.transaction.TransactionMixin">TransactionMixin</a></li>
<li><a title="python_pachyderm.mixin.version.VersionMixin" href="mixin/version.html#python_pachyderm.mixin.version.VersionMixin">VersionMixin</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="python_pachyderm.Client.new_from_config"><code class="name flex">
<span>def <span class="ident">new_from_config</span></span>(<span>config_file=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a Pachyderm client from a config file, which can either be
passed in as a file-like object, or if unset, checks the PACH_CONFIG env
var for a path. If that's also unset, it defaults to loading from
'~/.pachyderm/config.json'.</p>
<p>Params:</p>
<ul>
<li><code>config_file</code>: An optional file-like object containing the config
json file. If unspecified, we load the config from the default
location ('~/.pachyderm/config.json'.)</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def new_from_config(cls, config_file=None):
    &#34;&#34;&#34;
    Creates a Pachyderm client from a config file, which can either be
    passed in as a file-like object, or if unset, checks the PACH_CONFIG env
    var for a path. If that&#39;s also unset, it defaults to loading from
    &#39;~/.pachyderm/config.json&#39;.

    Params:

    * `config_file`: An optional file-like object containing the config
    json file. If unspecified, we load the config from the default
    location (&#39;~/.pachyderm/config.json&#39;.)
    &#34;&#34;&#34;

    if config_file is not None:
        j = json.load(config_file)
    elif &#34;PACH_CONFIG&#34; in os.environ:
        with open(os.environ.get(&#34;PACH_CONFIG&#34;), &#34;r&#34;) as config_file:
            j = json.load(config_file)
            print(&#34;config: {}&#34;.format(str(j)))
    else:
        try:
            # Search for config file in default home location
            with open(
                str(Path.home() / &#34;.pachyderm/config.json&#34;), &#34;r&#34;
            ) as config_file:
                j = json.load(config_file)
        except FileNotFoundError:
            # If not found, search in &#34;/pachctl&#34; (default mount for spout)
            with open(&#34;/pachctl/config.json&#34;, &#34;r&#34;) as config_file:
                j = json.load(config_file)

    try:
        active_context = j[&#34;v2&#34;][&#34;active_context&#34;]
    except KeyError:
        raise ConfigError(&#34;no active context&#34;)

    try:
        context = j[&#34;v2&#34;][&#34;contexts&#34;][active_context]
    except KeyError:
        raise ConfigError(&#34;missing active context &#39;{}&#39;&#34;.format(active_context))

    auth_token = context.get(&#34;session_token&#34;)
    root_certs = context.get(&#34;server_cas&#34;)
    transaction_id = context.get(&#34;active_transaction&#34;)

    pachd_address = context.get(&#34;pachd_address&#34;)
    if pachd_address:
        client = cls.new_from_pachd_address(
            pachd_address,
            auth_token=auth_token,
            root_certs=root_certs,
            transaction_id=transaction_id,
        )
    else:
        port_forwarders = context.get(&#34;port_forwarders&#34;, {})
        pachd_port = port_forwarders.get(&#34;pachd&#34;, 30650)
        pachd_address = &#34;grpc://localhost:{}&#34;.format(pachd_port)
        client = cls.new_from_pachd_address(
            pachd_address, auth_token=auth_token, transaction_id=transaction_id
        )

    expected_deployment_id = context.get(&#34;cluster_deployment_id&#34;)
    if expected_deployment_id:
        cluster_info = client.inspect_cluster()
        if cluster_info.deployment_id != expected_deployment_id:
            raise BadClusterDeploymentID(
                expected_deployment_id, cluster_info.deployment_id
            )

    return client</code></pre>
</details>
</dd>
<dt id="python_pachyderm.Client.new_from_pachd_address"><code class="name flex">
<span>def <span class="ident">new_from_pachd_address</span></span>(<span>pachd_address, auth_token=None, root_certs=None, transaction_id=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a Pachyderm client from a given pachd address.</p>
<p>Params:</p>
<ul>
<li><code>auth_token</code>: The authentication token; used if authentication is
enabled on the cluster. Default to <code>None</code>.</li>
<li><code>root_certs</code>: The PEM-encoded root certificates as byte string. If
unspecified, this will load default certs from certifi.</li>
<li><code>transaction_id</code>: The ID of the transaction to run operations on.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def new_from_pachd_address(
    cls, pachd_address, auth_token=None, root_certs=None, transaction_id=None
):
    &#34;&#34;&#34;
    Creates a Pachyderm client from a given pachd address.

    Params:

    * `auth_token`: The authentication token; used if authentication is
    enabled on the cluster. Default to `None`.
    * `root_certs`: The PEM-encoded root certificates as byte string. If
    unspecified, this will load default certs from certifi.
    * `transaction_id`: The ID of the transaction to run operations on.
    &#34;&#34;&#34;

    if &#34;://&#34; not in pachd_address:
        pachd_address = &#34;grpc://{}&#34;.format(pachd_address)

    u = urlparse(pachd_address)

    if u.scheme not in (&#34;grpc&#34;, &#34;http&#34;, &#34;grpcs&#34;, &#34;https&#34;):
        raise ValueError(&#34;unrecognized pachd address scheme: {}&#34;.format(u.scheme))
    if u.path != &#34;&#34; or u.params != &#34;&#34; or u.query != &#34;&#34; or u.fragment != &#34;&#34;:
        raise ValueError(&#34;invalid pachd address&#34;)
    if u.username is not None or u.password is not None:
        raise ValueError(&#34;invalid pachd address&#34;)

    return cls(
        host=u.hostname,
        port=u.port,
        auth_token=auth_token,
        root_certs=root_certs,
        transaction_id=transaction_id,
        tls=u.scheme == &#34;grpcs&#34; or u.scheme == &#34;https&#34;,
    )</code></pre>
</details>
</dd>
<dt id="python_pachyderm.Client.new_in_cluster"><code class="name flex">
<span>def <span class="ident">new_in_cluster</span></span>(<span>auth_token=None, transaction_id=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a Pachyderm client that operates within a Pachyderm cluster.</p>
<p>Params:</p>
<ul>
<li><code>auth_token</code>: The authentication token; used if authentication is
enabled on the cluster. Default to <code>None</code>.</li>
<li><code>transaction_id</code>: The ID of the transaction to run operations on.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def new_in_cluster(cls, auth_token=None, transaction_id=None):
    &#34;&#34;&#34;
    Creates a Pachyderm client that operates within a Pachyderm cluster.

    Params:

    * `auth_token`: The authentication token; used if authentication is
    enabled on the cluster. Default to `None`.
    * `transaction_id`: The ID of the transaction to run operations on.
    &#34;&#34;&#34;

    if (
        &#34;PACHD_PEER_SERVICE_HOST&#34; in os.environ
        and &#34;PACHD_PEER_SERVICE_PORT&#34; in os.environ
    ):
        # Try to use the pachd peer service if it&#39;s available. This is
        # only supported in pachyderm&gt;=1.10, but is more reliable because
        # it&#39;ll work when TLS is enabled on the cluster.
        host = os.environ[&#34;PACHD_PEER_SERVICE_HOST&#34;]
        port = int(os.environ[&#34;PACHD_PEER_SERVICE_PORT&#34;])
    else:
        # Otherwise use the normal service host/port, which will not work
        # when TLS is enabled on the cluster.
        host = os.environ[&#34;PACHD_SERVICE_HOST&#34;]
        port = int(os.environ[&#34;PACHD_SERVICE_PORT&#34;])

    return cls(
        host=host, port=port, auth_token=auth_token, transaction_id=transaction_id
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="python_pachyderm.Client.auth_token"><code class="name">var <span class="ident">auth_token</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def auth_token(self):
    return self._auth_token</code></pre>
</details>
</dd>
<dt id="python_pachyderm.Client.transaction_id"><code class="name">var <span class="ident">transaction_id</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def transaction_id(self):
    return self._transaction_id</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="python_pachyderm.mixin.admin.AdminMixin" href="mixin/admin.html#python_pachyderm.mixin.admin.AdminMixin">AdminMixin</a></b></code>:
<ul class="hlist">
<li><code><a title="python_pachyderm.mixin.admin.AdminMixin.inspect_cluster" href="mixin/admin.html#python_pachyderm.mixin.admin.AdminMixin.inspect_cluster">inspect_cluster</a></code></li>
</ul>
</li>
<li><code><b><a title="python_pachyderm.mixin.auth.AuthMixin" href="mixin/auth.html#python_pachyderm.mixin.auth.AuthMixin">AuthMixin</a></b></code>:
<ul class="hlist">
<li><code><a title="python_pachyderm.mixin.auth.AuthMixin.activate_auth" href="mixin/auth.html#python_pachyderm.mixin.auth.AuthMixin.activate_auth">activate_auth</a></code></li>
<li><code><a title="python_pachyderm.mixin.auth.AuthMixin.authenticate_id_token" href="mixin/auth.html#python_pachyderm.mixin.auth.AuthMixin.authenticate_id_token">authenticate_id_token</a></code></li>
<li><code><a title="python_pachyderm.mixin.auth.AuthMixin.authenticate_oidc" href="mixin/auth.html#python_pachyderm.mixin.auth.AuthMixin.authenticate_oidc">authenticate_oidc</a></code></li>
<li><code><a title="python_pachyderm.mixin.auth.AuthMixin.authorize" href="mixin/auth.html#python_pachyderm.mixin.auth.AuthMixin.authorize">authorize</a></code></li>
<li><code><a title="python_pachyderm.mixin.auth.AuthMixin.deactivate_auth" href="mixin/auth.html#python_pachyderm.mixin.auth.AuthMixin.deactivate_auth">deactivate_auth</a></code></li>
<li><code><a title="python_pachyderm.mixin.auth.AuthMixin.extract_auth_tokens" href="mixin/auth.html#python_pachyderm.mixin.auth.AuthMixin.extract_auth_tokens">extract_auth_tokens</a></code></li>
<li><code><a title="python_pachyderm.mixin.auth.AuthMixin.get_auth_configuration" href="mixin/auth.html#python_pachyderm.mixin.auth.AuthMixin.get_auth_configuration">get_auth_configuration</a></code></li>
<li><code><a title="python_pachyderm.mixin.auth.AuthMixin.get_groups" href="mixin/auth.html#python_pachyderm.mixin.auth.AuthMixin.get_groups">get_groups</a></code></li>
<li><code><a title="python_pachyderm.mixin.auth.AuthMixin.get_oidc_login" href="mixin/auth.html#python_pachyderm.mixin.auth.AuthMixin.get_oidc_login">get_oidc_login</a></code></li>
<li><code><a title="python_pachyderm.mixin.auth.AuthMixin.get_robot_token" href="mixin/auth.html#python_pachyderm.mixin.auth.AuthMixin.get_robot_token">get_robot_token</a></code></li>
<li><code><a title="python_pachyderm.mixin.auth.AuthMixin.get_role_binding" href="mixin/auth.html#python_pachyderm.mixin.auth.AuthMixin.get_role_binding">get_role_binding</a></code></li>
<li><code><a title="python_pachyderm.mixin.auth.AuthMixin.get_users" href="mixin/auth.html#python_pachyderm.mixin.auth.AuthMixin.get_users">get_users</a></code></li>
<li><code><a title="python_pachyderm.mixin.auth.AuthMixin.modify_members" href="mixin/auth.html#python_pachyderm.mixin.auth.AuthMixin.modify_members">modify_members</a></code></li>
<li><code><a title="python_pachyderm.mixin.auth.AuthMixin.modify_role_binding" href="mixin/auth.html#python_pachyderm.mixin.auth.AuthMixin.modify_role_binding">modify_role_binding</a></code></li>
<li><code><a title="python_pachyderm.mixin.auth.AuthMixin.restore_auth_token" href="mixin/auth.html#python_pachyderm.mixin.auth.AuthMixin.restore_auth_token">restore_auth_token</a></code></li>
<li><code><a title="python_pachyderm.mixin.auth.AuthMixin.revoke_auth_token" href="mixin/auth.html#python_pachyderm.mixin.auth.AuthMixin.revoke_auth_token">revoke_auth_token</a></code></li>
<li><code><a title="python_pachyderm.mixin.auth.AuthMixin.set_auth_configuration" href="mixin/auth.html#python_pachyderm.mixin.auth.AuthMixin.set_auth_configuration">set_auth_configuration</a></code></li>
<li><code><a title="python_pachyderm.mixin.auth.AuthMixin.set_groups_for_user" href="mixin/auth.html#python_pachyderm.mixin.auth.AuthMixin.set_groups_for_user">set_groups_for_user</a></code></li>
<li><code><a title="python_pachyderm.mixin.auth.AuthMixin.who_am_i" href="mixin/auth.html#python_pachyderm.mixin.auth.AuthMixin.who_am_i">who_am_i</a></code></li>
</ul>
</li>
<li><code><b><a title="python_pachyderm.mixin.debug.DebugMixin" href="mixin/debug.html#python_pachyderm.mixin.debug.DebugMixin">DebugMixin</a></b></code>:
<ul class="hlist">
<li><code><a title="python_pachyderm.mixin.debug.DebugMixin.binary" href="mixin/debug.html#python_pachyderm.mixin.debug.DebugMixin.binary">binary</a></code></li>
<li><code><a title="python_pachyderm.mixin.debug.DebugMixin.dump" href="mixin/debug.html#python_pachyderm.mixin.debug.DebugMixin.dump">dump</a></code></li>
<li><code><a title="python_pachyderm.mixin.debug.DebugMixin.profile_cpu" href="mixin/debug.html#python_pachyderm.mixin.debug.DebugMixin.profile_cpu">profile_cpu</a></code></li>
</ul>
</li>
<li><code><b><a title="python_pachyderm.mixin.enterprise.EnterpriseMixin" href="mixin/enterprise.html#python_pachyderm.mixin.enterprise.EnterpriseMixin">EnterpriseMixin</a></b></code>:
<ul class="hlist">
<li><code><a title="python_pachyderm.mixin.enterprise.EnterpriseMixin.activate_enterprise" href="mixin/enterprise.html#python_pachyderm.mixin.enterprise.EnterpriseMixin.activate_enterprise">activate_enterprise</a></code></li>
<li><code><a title="python_pachyderm.mixin.enterprise.EnterpriseMixin.deactivate_enterprise" href="mixin/enterprise.html#python_pachyderm.mixin.enterprise.EnterpriseMixin.deactivate_enterprise">deactivate_enterprise</a></code></li>
<li><code><a title="python_pachyderm.mixin.enterprise.EnterpriseMixin.get_activation_code" href="mixin/enterprise.html#python_pachyderm.mixin.enterprise.EnterpriseMixin.get_activation_code">get_activation_code</a></code></li>
<li><code><a title="python_pachyderm.mixin.enterprise.EnterpriseMixin.get_enterprise_state" href="mixin/enterprise.html#python_pachyderm.mixin.enterprise.EnterpriseMixin.get_enterprise_state">get_enterprise_state</a></code></li>
</ul>
</li>
<li><code><b><a title="python_pachyderm.mixin.identity.IdentityMixin" href="mixin/identity.html#python_pachyderm.mixin.identity.IdentityMixin">IdentityMixin</a></b></code>:
<ul class="hlist">
<li><code><a title="python_pachyderm.mixin.identity.IdentityMixin.create_idp_connector" href="mixin/identity.html#python_pachyderm.mixin.identity.IdentityMixin.create_idp_connector">create_idp_connector</a></code></li>
<li><code><a title="python_pachyderm.mixin.identity.IdentityMixin.create_oidc_client" href="mixin/identity.html#python_pachyderm.mixin.identity.IdentityMixin.create_oidc_client">create_oidc_client</a></code></li>
<li><code><a title="python_pachyderm.mixin.identity.IdentityMixin.delete_all_identity" href="mixin/identity.html#python_pachyderm.mixin.identity.IdentityMixin.delete_all_identity">delete_all_identity</a></code></li>
<li><code><a title="python_pachyderm.mixin.identity.IdentityMixin.delete_idp_connector" href="mixin/identity.html#python_pachyderm.mixin.identity.IdentityMixin.delete_idp_connector">delete_idp_connector</a></code></li>
<li><code><a title="python_pachyderm.mixin.identity.IdentityMixin.delete_oidc_client" href="mixin/identity.html#python_pachyderm.mixin.identity.IdentityMixin.delete_oidc_client">delete_oidc_client</a></code></li>
<li><code><a title="python_pachyderm.mixin.identity.IdentityMixin.get_identity_server_config" href="mixin/identity.html#python_pachyderm.mixin.identity.IdentityMixin.get_identity_server_config">get_identity_server_config</a></code></li>
<li><code><a title="python_pachyderm.mixin.identity.IdentityMixin.get_idp_connector" href="mixin/identity.html#python_pachyderm.mixin.identity.IdentityMixin.get_idp_connector">get_idp_connector</a></code></li>
<li><code><a title="python_pachyderm.mixin.identity.IdentityMixin.get_oidc_client" href="mixin/identity.html#python_pachyderm.mixin.identity.IdentityMixin.get_oidc_client">get_oidc_client</a></code></li>
<li><code><a title="python_pachyderm.mixin.identity.IdentityMixin.list_idp_connectors" href="mixin/identity.html#python_pachyderm.mixin.identity.IdentityMixin.list_idp_connectors">list_idp_connectors</a></code></li>
<li><code><a title="python_pachyderm.mixin.identity.IdentityMixin.list_oidc_clients" href="mixin/identity.html#python_pachyderm.mixin.identity.IdentityMixin.list_oidc_clients">list_oidc_clients</a></code></li>
<li><code><a title="python_pachyderm.mixin.identity.IdentityMixin.set_identity_server_config" href="mixin/identity.html#python_pachyderm.mixin.identity.IdentityMixin.set_identity_server_config">set_identity_server_config</a></code></li>
<li><code><a title="python_pachyderm.mixin.identity.IdentityMixin.update_idp_connector" href="mixin/identity.html#python_pachyderm.mixin.identity.IdentityMixin.update_idp_connector">update_idp_connector</a></code></li>
<li><code><a title="python_pachyderm.mixin.identity.IdentityMixin.update_oidc_client" href="mixin/identity.html#python_pachyderm.mixin.identity.IdentityMixin.update_oidc_client">update_oidc_client</a></code></li>
</ul>
</li>
<li><code><b><a title="python_pachyderm.mixin.license.LicenseMixin" href="mixin/license.html#python_pachyderm.mixin.license.LicenseMixin">LicenseMixin</a></b></code>:
<ul class="hlist">
<li><code><a title="python_pachyderm.mixin.license.LicenseMixin.activate_license" href="mixin/license.html#python_pachyderm.mixin.license.LicenseMixin.activate_license">activate_license</a></code></li>
<li><code><a title="python_pachyderm.mixin.license.LicenseMixin.add_cluster" href="mixin/license.html#python_pachyderm.mixin.license.LicenseMixin.add_cluster">add_cluster</a></code></li>
<li><code><a title="python_pachyderm.mixin.license.LicenseMixin.delete_all_license" href="mixin/license.html#python_pachyderm.mixin.license.LicenseMixin.delete_all_license">delete_all_license</a></code></li>
<li><code><a title="python_pachyderm.mixin.license.LicenseMixin.delete_cluster" href="mixin/license.html#python_pachyderm.mixin.license.LicenseMixin.delete_cluster">delete_cluster</a></code></li>
<li><code><a title="python_pachyderm.mixin.license.LicenseMixin.list_clusters" href="mixin/license.html#python_pachyderm.mixin.license.LicenseMixin.list_clusters">list_clusters</a></code></li>
<li><code><a title="python_pachyderm.mixin.license.LicenseMixin.list_user_clusters" href="mixin/license.html#python_pachyderm.mixin.license.LicenseMixin.list_user_clusters">list_user_clusters</a></code></li>
<li><code><a title="python_pachyderm.mixin.license.LicenseMixin.update_cluster" href="mixin/license.html#python_pachyderm.mixin.license.LicenseMixin.update_cluster">update_cluster</a></code></li>
</ul>
</li>
<li><code><b><a title="python_pachyderm.mixin.pfs.PFSMixin" href="mixin/pfs.html#python_pachyderm.mixin.pfs.PFSMixin">PFSMixin</a></b></code>:
<ul class="hlist">
<li><code><a title="python_pachyderm.mixin.pfs.PFSMixin.commit" href="mixin/pfs.html#python_pachyderm.mixin.pfs.PFSMixin.commit">commit</a></code></li>
<li><code><a title="python_pachyderm.mixin.pfs.PFSMixin.copy_file" href="mixin/pfs.html#python_pachyderm.mixin.pfs.PFSMixin.copy_file">copy_file</a></code></li>
<li><code><a title="python_pachyderm.mixin.pfs.PFSMixin.create_branch" href="mixin/pfs.html#python_pachyderm.mixin.pfs.PFSMixin.create_branch">create_branch</a></code></li>
<li><code><a title="python_pachyderm.mixin.pfs.PFSMixin.create_repo" href="mixin/pfs.html#python_pachyderm.mixin.pfs.PFSMixin.create_repo">create_repo</a></code></li>
<li><code><a title="python_pachyderm.mixin.pfs.PFSMixin.create_tmp_file_set" href="mixin/pfs.html#python_pachyderm.mixin.pfs.PFSMixin.create_tmp_file_set">create_tmp_file_set</a></code></li>
<li><code><a title="python_pachyderm.mixin.pfs.PFSMixin.delete_all_repos" href="mixin/pfs.html#python_pachyderm.mixin.pfs.PFSMixin.delete_all_repos">delete_all_repos</a></code></li>
<li><code><a title="python_pachyderm.mixin.pfs.PFSMixin.delete_branch" href="mixin/pfs.html#python_pachyderm.mixin.pfs.PFSMixin.delete_branch">delete_branch</a></code></li>
<li><code><a title="python_pachyderm.mixin.pfs.PFSMixin.delete_file" href="mixin/pfs.html#python_pachyderm.mixin.pfs.PFSMixin.delete_file">delete_file</a></code></li>
<li><code><a title="python_pachyderm.mixin.pfs.PFSMixin.delete_repo" href="mixin/pfs.html#python_pachyderm.mixin.pfs.PFSMixin.delete_repo">delete_repo</a></code></li>
<li><code><a title="python_pachyderm.mixin.pfs.PFSMixin.diff_file" href="mixin/pfs.html#python_pachyderm.mixin.pfs.PFSMixin.diff_file">diff_file</a></code></li>
<li><code><a title="python_pachyderm.mixin.pfs.PFSMixin.finish_commit" href="mixin/pfs.html#python_pachyderm.mixin.pfs.PFSMixin.finish_commit">finish_commit</a></code></li>
<li><code><a title="python_pachyderm.mixin.pfs.PFSMixin.flush_commit" href="mixin/pfs.html#python_pachyderm.mixin.pfs.PFSMixin.flush_commit">flush_commit</a></code></li>
<li><code><a title="python_pachyderm.mixin.pfs.PFSMixin.fsck" href="mixin/pfs.html#python_pachyderm.mixin.pfs.PFSMixin.fsck">fsck</a></code></li>
<li><code><a title="python_pachyderm.mixin.pfs.PFSMixin.get_file" href="mixin/pfs.html#python_pachyderm.mixin.pfs.PFSMixin.get_file">get_file</a></code></li>
<li><code><a title="python_pachyderm.mixin.pfs.PFSMixin.glob_file" href="mixin/pfs.html#python_pachyderm.mixin.pfs.PFSMixin.glob_file">glob_file</a></code></li>
<li><code><a title="python_pachyderm.mixin.pfs.PFSMixin.inspect_branch" href="mixin/pfs.html#python_pachyderm.mixin.pfs.PFSMixin.inspect_branch">inspect_branch</a></code></li>
<li><code><a title="python_pachyderm.mixin.pfs.PFSMixin.inspect_commit" href="mixin/pfs.html#python_pachyderm.mixin.pfs.PFSMixin.inspect_commit">inspect_commit</a></code></li>
<li><code><a title="python_pachyderm.mixin.pfs.PFSMixin.inspect_file" href="mixin/pfs.html#python_pachyderm.mixin.pfs.PFSMixin.inspect_file">inspect_file</a></code></li>
<li><code><a title="python_pachyderm.mixin.pfs.PFSMixin.inspect_repo" href="mixin/pfs.html#python_pachyderm.mixin.pfs.PFSMixin.inspect_repo">inspect_repo</a></code></li>
<li><code><a title="python_pachyderm.mixin.pfs.PFSMixin.list_branch" href="mixin/pfs.html#python_pachyderm.mixin.pfs.PFSMixin.list_branch">list_branch</a></code></li>
<li><code><a title="python_pachyderm.mixin.pfs.PFSMixin.list_commit" href="mixin/pfs.html#python_pachyderm.mixin.pfs.PFSMixin.list_commit">list_commit</a></code></li>
<li><code><a title="python_pachyderm.mixin.pfs.PFSMixin.list_file" href="mixin/pfs.html#python_pachyderm.mixin.pfs.PFSMixin.list_file">list_file</a></code></li>
<li><code><a title="python_pachyderm.mixin.pfs.PFSMixin.list_repo" href="mixin/pfs.html#python_pachyderm.mixin.pfs.PFSMixin.list_repo">list_repo</a></code></li>
<li><code><a title="python_pachyderm.mixin.pfs.PFSMixin.modify_file_client" href="mixin/pfs.html#python_pachyderm.mixin.pfs.PFSMixin.modify_file_client">modify_file_client</a></code></li>
<li><code><a title="python_pachyderm.mixin.pfs.PFSMixin.put_file_bytes" href="mixin/pfs.html#python_pachyderm.mixin.pfs.PFSMixin.put_file_bytes">put_file_bytes</a></code></li>
<li><code><a title="python_pachyderm.mixin.pfs.PFSMixin.put_file_url" href="mixin/pfs.html#python_pachyderm.mixin.pfs.PFSMixin.put_file_url">put_file_url</a></code></li>
<li><code><a title="python_pachyderm.mixin.pfs.PFSMixin.renew_tmp_file_set" href="mixin/pfs.html#python_pachyderm.mixin.pfs.PFSMixin.renew_tmp_file_set">renew_tmp_file_set</a></code></li>
<li><code><a title="python_pachyderm.mixin.pfs.PFSMixin.squash_commit" href="mixin/pfs.html#python_pachyderm.mixin.pfs.PFSMixin.squash_commit">squash_commit</a></code></li>
<li><code><a title="python_pachyderm.mixin.pfs.PFSMixin.start_commit" href="mixin/pfs.html#python_pachyderm.mixin.pfs.PFSMixin.start_commit">start_commit</a></code></li>
<li><code><a title="python_pachyderm.mixin.pfs.PFSMixin.subscribe_commit" href="mixin/pfs.html#python_pachyderm.mixin.pfs.PFSMixin.subscribe_commit">subscribe_commit</a></code></li>
<li><code><a title="python_pachyderm.mixin.pfs.PFSMixin.walk_file" href="mixin/pfs.html#python_pachyderm.mixin.pfs.PFSMixin.walk_file">walk_file</a></code></li>
</ul>
</li>
<li><code><b><a title="python_pachyderm.mixin.pps.PPSMixin" href="mixin/pps.html#python_pachyderm.mixin.pps.PPSMixin">PPSMixin</a></b></code>:
<ul class="hlist">
<li><code><a title="python_pachyderm.mixin.pps.PPSMixin.create_pipeline" href="mixin/pps.html#python_pachyderm.mixin.pps.PPSMixin.create_pipeline">create_pipeline</a></code></li>
<li><code><a title="python_pachyderm.mixin.pps.PPSMixin.create_pipeline_from_request" href="mixin/pps.html#python_pachyderm.mixin.pps.PPSMixin.create_pipeline_from_request">create_pipeline_from_request</a></code></li>
<li><code><a title="python_pachyderm.mixin.pps.PPSMixin.create_secret" href="mixin/pps.html#python_pachyderm.mixin.pps.PPSMixin.create_secret">create_secret</a></code></li>
<li><code><a title="python_pachyderm.mixin.pps.PPSMixin.delete_all" href="mixin/pps.html#python_pachyderm.mixin.pps.PPSMixin.delete_all">delete_all</a></code></li>
<li><code><a title="python_pachyderm.mixin.pps.PPSMixin.delete_all_pipelines" href="mixin/pps.html#python_pachyderm.mixin.pps.PPSMixin.delete_all_pipelines">delete_all_pipelines</a></code></li>
<li><code><a title="python_pachyderm.mixin.pps.PPSMixin.delete_job" href="mixin/pps.html#python_pachyderm.mixin.pps.PPSMixin.delete_job">delete_job</a></code></li>
<li><code><a title="python_pachyderm.mixin.pps.PPSMixin.delete_pipeline" href="mixin/pps.html#python_pachyderm.mixin.pps.PPSMixin.delete_pipeline">delete_pipeline</a></code></li>
<li><code><a title="python_pachyderm.mixin.pps.PPSMixin.delete_secret" href="mixin/pps.html#python_pachyderm.mixin.pps.PPSMixin.delete_secret">delete_secret</a></code></li>
<li><code><a title="python_pachyderm.mixin.pps.PPSMixin.flush_job" href="mixin/pps.html#python_pachyderm.mixin.pps.PPSMixin.flush_job">flush_job</a></code></li>
<li><code><a title="python_pachyderm.mixin.pps.PPSMixin.get_job_logs" href="mixin/pps.html#python_pachyderm.mixin.pps.PPSMixin.get_job_logs">get_job_logs</a></code></li>
<li><code><a title="python_pachyderm.mixin.pps.PPSMixin.get_pipeline_logs" href="mixin/pps.html#python_pachyderm.mixin.pps.PPSMixin.get_pipeline_logs">get_pipeline_logs</a></code></li>
<li><code><a title="python_pachyderm.mixin.pps.PPSMixin.inspect_datum" href="mixin/pps.html#python_pachyderm.mixin.pps.PPSMixin.inspect_datum">inspect_datum</a></code></li>
<li><code><a title="python_pachyderm.mixin.pps.PPSMixin.inspect_job" href="mixin/pps.html#python_pachyderm.mixin.pps.PPSMixin.inspect_job">inspect_job</a></code></li>
<li><code><a title="python_pachyderm.mixin.pps.PPSMixin.inspect_pipeline" href="mixin/pps.html#python_pachyderm.mixin.pps.PPSMixin.inspect_pipeline">inspect_pipeline</a></code></li>
<li><code><a title="python_pachyderm.mixin.pps.PPSMixin.inspect_secret" href="mixin/pps.html#python_pachyderm.mixin.pps.PPSMixin.inspect_secret">inspect_secret</a></code></li>
<li><code><a title="python_pachyderm.mixin.pps.PPSMixin.list_datum" href="mixin/pps.html#python_pachyderm.mixin.pps.PPSMixin.list_datum">list_datum</a></code></li>
<li><code><a title="python_pachyderm.mixin.pps.PPSMixin.list_job" href="mixin/pps.html#python_pachyderm.mixin.pps.PPSMixin.list_job">list_job</a></code></li>
<li><code><a title="python_pachyderm.mixin.pps.PPSMixin.list_pipeline" href="mixin/pps.html#python_pachyderm.mixin.pps.PPSMixin.list_pipeline">list_pipeline</a></code></li>
<li><code><a title="python_pachyderm.mixin.pps.PPSMixin.list_secret" href="mixin/pps.html#python_pachyderm.mixin.pps.PPSMixin.list_secret">list_secret</a></code></li>
<li><code><a title="python_pachyderm.mixin.pps.PPSMixin.restart_datum" href="mixin/pps.html#python_pachyderm.mixin.pps.PPSMixin.restart_datum">restart_datum</a></code></li>
<li><code><a title="python_pachyderm.mixin.pps.PPSMixin.run_cron" href="mixin/pps.html#python_pachyderm.mixin.pps.PPSMixin.run_cron">run_cron</a></code></li>
<li><code><a title="python_pachyderm.mixin.pps.PPSMixin.run_pipeline" href="mixin/pps.html#python_pachyderm.mixin.pps.PPSMixin.run_pipeline">run_pipeline</a></code></li>
<li><code><a title="python_pachyderm.mixin.pps.PPSMixin.start_pipeline" href="mixin/pps.html#python_pachyderm.mixin.pps.PPSMixin.start_pipeline">start_pipeline</a></code></li>
<li><code><a title="python_pachyderm.mixin.pps.PPSMixin.stop_job" href="mixin/pps.html#python_pachyderm.mixin.pps.PPSMixin.stop_job">stop_job</a></code></li>
<li><code><a title="python_pachyderm.mixin.pps.PPSMixin.stop_pipeline" href="mixin/pps.html#python_pachyderm.mixin.pps.PPSMixin.stop_pipeline">stop_pipeline</a></code></li>
</ul>
</li>
<li><code><b><a title="python_pachyderm.mixin.transaction.TransactionMixin" href="mixin/transaction.html#python_pachyderm.mixin.transaction.TransactionMixin">TransactionMixin</a></b></code>:
<ul class="hlist">
<li><code><a title="python_pachyderm.mixin.transaction.TransactionMixin.batch_transaction" href="mixin/transaction.html#python_pachyderm.mixin.transaction.TransactionMixin.batch_transaction">batch_transaction</a></code></li>
<li><code><a title="python_pachyderm.mixin.transaction.TransactionMixin.delete_all_transactions" href="mixin/transaction.html#python_pachyderm.mixin.transaction.TransactionMixin.delete_all_transactions">delete_all_transactions</a></code></li>
<li><code><a title="python_pachyderm.mixin.transaction.TransactionMixin.delete_transaction" href="mixin/transaction.html#python_pachyderm.mixin.transaction.TransactionMixin.delete_transaction">delete_transaction</a></code></li>
<li><code><a title="python_pachyderm.mixin.transaction.TransactionMixin.finish_transaction" href="mixin/transaction.html#python_pachyderm.mixin.transaction.TransactionMixin.finish_transaction">finish_transaction</a></code></li>
<li><code><a title="python_pachyderm.mixin.transaction.TransactionMixin.inspect_transaction" href="mixin/transaction.html#python_pachyderm.mixin.transaction.TransactionMixin.inspect_transaction">inspect_transaction</a></code></li>
<li><code><a title="python_pachyderm.mixin.transaction.TransactionMixin.list_transaction" href="mixin/transaction.html#python_pachyderm.mixin.transaction.TransactionMixin.list_transaction">list_transaction</a></code></li>
<li><code><a title="python_pachyderm.mixin.transaction.TransactionMixin.start_transaction" href="mixin/transaction.html#python_pachyderm.mixin.transaction.TransactionMixin.start_transaction">start_transaction</a></code></li>
<li><code><a title="python_pachyderm.mixin.transaction.TransactionMixin.transaction" href="mixin/transaction.html#python_pachyderm.mixin.transaction.TransactionMixin.transaction">transaction</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="python_pachyderm.ConfigError"><code class="flex name class">
<span>class <span class="ident">ConfigError</span></span>
<span>(</span><span>message)</span>
</code></dt>
<dd>
<div class="desc"><p>Error for issues related to the pachyderm config file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ConfigError(Exception):
    &#34;&#34;&#34;Error for issues related to the pachyderm config file&#34;&#34;&#34;

    def __init__(self, message):
        super().__init__(message)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="python_pachyderm.client.BadClusterDeploymentID" href="client.html#python_pachyderm.client.BadClusterDeploymentID">BadClusterDeploymentID</a></li>
</ul>
</dd>
<dt id="python_pachyderm.ModifyFileClient"><code class="flex name class">
<span>class <span class="ident">ModifyFileClient</span></span>
<span>(</span><span>commit)</span>
</code></dt>
<dd>
<div class="desc"><p><code><a title="python_pachyderm.ModifyFileClient" href="#python_pachyderm.ModifyFileClient">ModifyFileClient</a></code> puts or deletes PFS files atomically.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ModifyFileClient:
    &#34;&#34;&#34;
    `ModifyFileClient` puts or deletes PFS files atomically.
    &#34;&#34;&#34;

    def __init__(self, commit):
        self._ops = []
        self.commit = commit_from(commit)

    def _reqs(self):
        for op in self._ops:
            for r in op.reqs():
                yield r

    def put_file_from_filepath(
        self,
        pfs_path,
        local_path,
        append=None,
        delimiter=None,
        target_file_datums=None,
        target_file_bytes=None,
        header_records=None,
    ):
        &#34;&#34;&#34;
        Uploads a PFS file from a local path at a specified path. This will
        lazily open files, which will prevent too many files from being
        opened, or too much memory being consumed, when atomically putting
        many files.

        Params:

        * `pfs_path`: A string specifying the path in the repo the file(s)
        will be written to.
        * `local_path`: A string specifying the local file path.
        * `append`: An optional bool, if true the data is appended to the file,
        if it already exists.
        * `delimiter`: An optional int. causes data to be broken up into
        separate files by the delimiter. e.g. if you used
        `Delimiter.CSV.value`, a separate PFS file will be created for each
        row in the input CSV file, rather than one large CSV file.
        * `target_file_datums`: An optional int. Specifies the target number of
        datums in each written file. It may be lower if data does not split
        evenly, but will never be higher, unless the value is 0.
        * `target_file_bytes`: An optional int. Specifies the target number of
        bytes in each written file, files may have more or fewer bytes than
        the target.
        * `header_records: An optional int for splitting data when `delimiter`
        is not `NONE` (or `SQL`). It specifies the number of records that are
        converted to a header and applied to all file shards.
        &#34;&#34;&#34;
        self._ops.append(
            AtomicModifyFilepathOp(
                self.commit,
                pfs_path,
                local_path,
                append,
                # delimiter=delimiter,
                # target_file_datums=target_file_datums,
                # target_file_bytes=target_file_bytes,
                # header_records=header_records,
            )
        )

    def put_file_from_fileobj(
        self,
        path,
        value,
        append=None,
        delimiter=None,
        target_file_datums=None,
        target_file_bytes=None,
        header_records=None,
    ):
        &#34;&#34;&#34;
        Uploads a PFS file from a file-like object.

        Params:

        * `path`: A string specifying the path in the repo the file(s) will be
        written to.
        * `value`: The file-like object.
        * `append`: An optional bool, if true the data is appended to the file,
        if it already exists.
        * `delimiter`: An optional int. causes data to be broken up into
        separate files by the delimiter. e.g. if you used
        `Delimiter.CSV.value`, a separate PFS file will be created for each
        row in the input CSV file, rather than one large CSV file.
        * `target_file_datums`: An optional int. Specifies the target number of
        datums in each written file. It may be lower if data does not split
        evenly, but will never be higher, unless the value is 0.
        * `target_file_bytes`: An optional int. Specifies the target number of
        bytes in each written file, files may have more or fewer bytes than
        the target.
        * `header_records: An optional int for splitting data when `delimiter`
        is not `NONE` (or `SQL`). It specifies the number of records that are
        converted to a header and applied to all file shards.
        &#34;&#34;&#34;
        self._ops.append(
            AtomicModifyFileobjOp(
                self.commit,
                path,
                value,
                append,
                # delimiter=delimiter,
                # target_file_datums=target_file_datums,
                # target_file_bytes=target_file_bytes,
                # header_records=header_records,
            )
        )

    def put_file_from_bytes(
        self,
        path,
        value,
        append=None,
        delimiter=None,
        target_file_datums=None,
        target_file_bytes=None,
        header_records=None,
    ):
        &#34;&#34;&#34;
        Uploads a PFS file from a bytestring.

        Params:

        * `path`: A string specifying the path in the repo the file(s) will be
        written to.
        * `value`: The file contents as a bytestring.
        * `append`: An optional bool, if true the data is appended to the file,
        if it already exists.
        * `delimiter`: An optional int. causes data to be broken up into
        separate files by the delimiter. e.g. if you used
        `Delimiter.CSV.value`, a separate PFS file will be created for each
        row in the input CSV file, rather than one large CSV file.
        * `target_file_datums`: An optional int. Specifies the target number of
        datums in each written file. It may be lower if data does not split
        evenly, but will never be higher, unless the value is 0.
        * `target_file_bytes`: An optional int. Specifies the target number of
        bytes in each written file, files may have more or fewer bytes than
        the target.
        * `header_records: An optional int for splitting data when `delimiter`
        is not `NONE` (or `SQL`). It specifies the number of records that are
        converted to a header and applied to all file shards.
        &#34;&#34;&#34;
        self.put_file_from_fileobj(
            path,
            io.BytesIO(value),
            append,
            # delimiter=delimiter,
            # target_file_datums=target_file_datums,
            # target_file_bytes=target_file_bytes,
            # header_records=header_records,
        )

    def put_file_from_url(
        self,
        path,
        url,
        append=None,
        delimiter=None,
        recursive=None,
        target_file_datums=None,
        target_file_bytes=None,
        header_records=None,
    ):
        &#34;&#34;&#34;
        Puts a file using the content found at a URL. The URL is sent to the
        server which performs the request.

        Params:

        * `path`: A string specifying the path to the file.
        * `url`: A string specifying the url of the file to put.
        * `append`: An optional bool, if true the data is appended to the file,
        if it already exists.
        * `delimiter`: An optional int. causes data to be broken up into
        separate files by the delimiter. e.g. if you used
        `Delimiter.CSV.value`, a separate PFS file will be created for each
        row in the input CSV file, rather than one large CSV file.
        * `recursive`: allow for recursive scraping of some types URLs, for
        example on s3:// URLs.
        * `target_file_datums`: An optional int. Specifies the target number of
        datums in each written file. It may be lower if data does not split
        evenly, but will never be higher, unless the value is 0.
        * `target_file_bytes`: An optional int. Specifies the target number of
        bytes in each written file, files may have more or fewer bytes than
        the target.
        * `header_records: An optional int for splitting data when `delimiter`
        is not `NONE` (or `SQL`). It specifies the number of records that are
        converted to a header and applied to all file shards.
        &#34;&#34;&#34;
        self._ops.append(
            AtomicModifyFileURLOp(
                self.commit,
                path,
                url,
                append,
                recursive=recursive,
                # delimiter=delimiter,
                # target_file_datums=target_file_datums,
                # target_file_bytes=target_file_bytes,
                # header_records=header_records,
            )
        )

    def delete_file(self, path):
        &#34;&#34;&#34;
        Deletes a file.

        Params:

        * `path`: The path to the file.
        &#34;&#34;&#34;
        self._ops.append(AtomicDeleteFileOp(self.commit, path))

    def copy_file(self, source_commit, source_path, dest_path, append=None, tag=None):
        &#34;&#34;&#34;
        Copy a file.

        Params:

        * `source_commit`: The commit the source file is in.
        * `source_path`: The path to the source file.
        * `dest_path`: The path to the destination file.
        * `append`: An optional bool, if true the data is appended to the file,
        if it already exists.
        &#34;&#34;&#34;
        self._ops.append(
            AtomicCopyFileOp(
                self.commit,
                source_commit,
                source_path,
                dest_path,
                append=append,
                tag=tag,
            )
        )</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="python_pachyderm.ModifyFileClient.copy_file"><code class="name flex">
<span>def <span class="ident">copy_file</span></span>(<span>self, source_commit, source_path, dest_path, append=None, tag=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Copy a file.</p>
<p>Params:</p>
<ul>
<li><code>source_commit</code>: The commit the source file is in.</li>
<li><code>source_path</code>: The path to the source file.</li>
<li><code>dest_path</code>: The path to the destination file.</li>
<li><code>append</code>: An optional bool, if true the data is appended to the file,
if it already exists.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy_file(self, source_commit, source_path, dest_path, append=None, tag=None):
    &#34;&#34;&#34;
    Copy a file.

    Params:

    * `source_commit`: The commit the source file is in.
    * `source_path`: The path to the source file.
    * `dest_path`: The path to the destination file.
    * `append`: An optional bool, if true the data is appended to the file,
    if it already exists.
    &#34;&#34;&#34;
    self._ops.append(
        AtomicCopyFileOp(
            self.commit,
            source_commit,
            source_path,
            dest_path,
            append=append,
            tag=tag,
        )
    )</code></pre>
</details>
</dd>
<dt id="python_pachyderm.ModifyFileClient.delete_file"><code class="name flex">
<span>def <span class="ident">delete_file</span></span>(<span>self, path)</span>
</code></dt>
<dd>
<div class="desc"><p>Deletes a file.</p>
<p>Params:</p>
<ul>
<li><code>path</code>: The path to the file.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_file(self, path):
    &#34;&#34;&#34;
    Deletes a file.

    Params:

    * `path`: The path to the file.
    &#34;&#34;&#34;
    self._ops.append(AtomicDeleteFileOp(self.commit, path))</code></pre>
</details>
</dd>
<dt id="python_pachyderm.ModifyFileClient.put_file_from_bytes"><code class="name flex">
<span>def <span class="ident">put_file_from_bytes</span></span>(<span>self, path, value, append=None, delimiter=None, target_file_datums=None, target_file_bytes=None, header_records=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Uploads a PFS file from a bytestring.</p>
<p>Params:</p>
<ul>
<li><code>path</code>: A string specifying the path in the repo the file(s) will be
written to.</li>
<li><code>value</code>: The file contents as a bytestring.</li>
<li><code>append</code>: An optional bool, if true the data is appended to the file,
if it already exists.</li>
<li><code>delimiter</code>: An optional int. causes data to be broken up into
separate files by the delimiter. e.g. if you used
<code>Delimiter.CSV.value</code>, a separate PFS file will be created for each
row in the input CSV file, rather than one large CSV file.</li>
<li><code>target_file_datums</code>: An optional int. Specifies the target number of
datums in each written file. It may be lower if data does not split
evenly, but will never be higher, unless the value is 0.</li>
<li><code>target_file_bytes</code>: An optional int. Specifies the target number of
bytes in each written file, files may have more or fewer bytes than
the target.</li>
<li><code>header_records: An optional int for splitting data when</code>delimiter`
is not <code>NONE</code> (or <code>SQL</code>). It specifies the number of records that are
converted to a header and applied to all file shards.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_file_from_bytes(
    self,
    path,
    value,
    append=None,
    delimiter=None,
    target_file_datums=None,
    target_file_bytes=None,
    header_records=None,
):
    &#34;&#34;&#34;
    Uploads a PFS file from a bytestring.

    Params:

    * `path`: A string specifying the path in the repo the file(s) will be
    written to.
    * `value`: The file contents as a bytestring.
    * `append`: An optional bool, if true the data is appended to the file,
    if it already exists.
    * `delimiter`: An optional int. causes data to be broken up into
    separate files by the delimiter. e.g. if you used
    `Delimiter.CSV.value`, a separate PFS file will be created for each
    row in the input CSV file, rather than one large CSV file.
    * `target_file_datums`: An optional int. Specifies the target number of
    datums in each written file. It may be lower if data does not split
    evenly, but will never be higher, unless the value is 0.
    * `target_file_bytes`: An optional int. Specifies the target number of
    bytes in each written file, files may have more or fewer bytes than
    the target.
    * `header_records: An optional int for splitting data when `delimiter`
    is not `NONE` (or `SQL`). It specifies the number of records that are
    converted to a header and applied to all file shards.
    &#34;&#34;&#34;
    self.put_file_from_fileobj(
        path,
        io.BytesIO(value),
        append,
        # delimiter=delimiter,
        # target_file_datums=target_file_datums,
        # target_file_bytes=target_file_bytes,
        # header_records=header_records,
    )</code></pre>
</details>
</dd>
<dt id="python_pachyderm.ModifyFileClient.put_file_from_fileobj"><code class="name flex">
<span>def <span class="ident">put_file_from_fileobj</span></span>(<span>self, path, value, append=None, delimiter=None, target_file_datums=None, target_file_bytes=None, header_records=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Uploads a PFS file from a file-like object.</p>
<p>Params:</p>
<ul>
<li><code>path</code>: A string specifying the path in the repo the file(s) will be
written to.</li>
<li><code>value</code>: The file-like object.</li>
<li><code>append</code>: An optional bool, if true the data is appended to the file,
if it already exists.</li>
<li><code>delimiter</code>: An optional int. causes data to be broken up into
separate files by the delimiter. e.g. if you used
<code>Delimiter.CSV.value</code>, a separate PFS file will be created for each
row in the input CSV file, rather than one large CSV file.</li>
<li><code>target_file_datums</code>: An optional int. Specifies the target number of
datums in each written file. It may be lower if data does not split
evenly, but will never be higher, unless the value is 0.</li>
<li><code>target_file_bytes</code>: An optional int. Specifies the target number of
bytes in each written file, files may have more or fewer bytes than
the target.</li>
<li><code>header_records: An optional int for splitting data when</code>delimiter`
is not <code>NONE</code> (or <code>SQL</code>). It specifies the number of records that are
converted to a header and applied to all file shards.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_file_from_fileobj(
    self,
    path,
    value,
    append=None,
    delimiter=None,
    target_file_datums=None,
    target_file_bytes=None,
    header_records=None,
):
    &#34;&#34;&#34;
    Uploads a PFS file from a file-like object.

    Params:

    * `path`: A string specifying the path in the repo the file(s) will be
    written to.
    * `value`: The file-like object.
    * `append`: An optional bool, if true the data is appended to the file,
    if it already exists.
    * `delimiter`: An optional int. causes data to be broken up into
    separate files by the delimiter. e.g. if you used
    `Delimiter.CSV.value`, a separate PFS file will be created for each
    row in the input CSV file, rather than one large CSV file.
    * `target_file_datums`: An optional int. Specifies the target number of
    datums in each written file. It may be lower if data does not split
    evenly, but will never be higher, unless the value is 0.
    * `target_file_bytes`: An optional int. Specifies the target number of
    bytes in each written file, files may have more or fewer bytes than
    the target.
    * `header_records: An optional int for splitting data when `delimiter`
    is not `NONE` (or `SQL`). It specifies the number of records that are
    converted to a header and applied to all file shards.
    &#34;&#34;&#34;
    self._ops.append(
        AtomicModifyFileobjOp(
            self.commit,
            path,
            value,
            append,
            # delimiter=delimiter,
            # target_file_datums=target_file_datums,
            # target_file_bytes=target_file_bytes,
            # header_records=header_records,
        )
    )</code></pre>
</details>
</dd>
<dt id="python_pachyderm.ModifyFileClient.put_file_from_filepath"><code class="name flex">
<span>def <span class="ident">put_file_from_filepath</span></span>(<span>self, pfs_path, local_path, append=None, delimiter=None, target_file_datums=None, target_file_bytes=None, header_records=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Uploads a PFS file from a local path at a specified path. This will
lazily open files, which will prevent too many files from being
opened, or too much memory being consumed, when atomically putting
many files.</p>
<p>Params:</p>
<ul>
<li><code>pfs_path</code>: A string specifying the path in the repo the file(s)
will be written to.</li>
<li><code>local_path</code>: A string specifying the local file path.</li>
<li><code>append</code>: An optional bool, if true the data is appended to the file,
if it already exists.</li>
<li><code>delimiter</code>: An optional int. causes data to be broken up into
separate files by the delimiter. e.g. if you used
<code>Delimiter.CSV.value</code>, a separate PFS file will be created for each
row in the input CSV file, rather than one large CSV file.</li>
<li><code>target_file_datums</code>: An optional int. Specifies the target number of
datums in each written file. It may be lower if data does not split
evenly, but will never be higher, unless the value is 0.</li>
<li><code>target_file_bytes</code>: An optional int. Specifies the target number of
bytes in each written file, files may have more or fewer bytes than
the target.</li>
<li><code>header_records: An optional int for splitting data when</code>delimiter`
is not <code>NONE</code> (or <code>SQL</code>). It specifies the number of records that are
converted to a header and applied to all file shards.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_file_from_filepath(
    self,
    pfs_path,
    local_path,
    append=None,
    delimiter=None,
    target_file_datums=None,
    target_file_bytes=None,
    header_records=None,
):
    &#34;&#34;&#34;
    Uploads a PFS file from a local path at a specified path. This will
    lazily open files, which will prevent too many files from being
    opened, or too much memory being consumed, when atomically putting
    many files.

    Params:

    * `pfs_path`: A string specifying the path in the repo the file(s)
    will be written to.
    * `local_path`: A string specifying the local file path.
    * `append`: An optional bool, if true the data is appended to the file,
    if it already exists.
    * `delimiter`: An optional int. causes data to be broken up into
    separate files by the delimiter. e.g. if you used
    `Delimiter.CSV.value`, a separate PFS file will be created for each
    row in the input CSV file, rather than one large CSV file.
    * `target_file_datums`: An optional int. Specifies the target number of
    datums in each written file. It may be lower if data does not split
    evenly, but will never be higher, unless the value is 0.
    * `target_file_bytes`: An optional int. Specifies the target number of
    bytes in each written file, files may have more or fewer bytes than
    the target.
    * `header_records: An optional int for splitting data when `delimiter`
    is not `NONE` (or `SQL`). It specifies the number of records that are
    converted to a header and applied to all file shards.
    &#34;&#34;&#34;
    self._ops.append(
        AtomicModifyFilepathOp(
            self.commit,
            pfs_path,
            local_path,
            append,
            # delimiter=delimiter,
            # target_file_datums=target_file_datums,
            # target_file_bytes=target_file_bytes,
            # header_records=header_records,
        )
    )</code></pre>
</details>
</dd>
<dt id="python_pachyderm.ModifyFileClient.put_file_from_url"><code class="name flex">
<span>def <span class="ident">put_file_from_url</span></span>(<span>self, path, url, append=None, delimiter=None, recursive=None, target_file_datums=None, target_file_bytes=None, header_records=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Puts a file using the content found at a URL. The URL is sent to the
server which performs the request.</p>
<p>Params:</p>
<ul>
<li><code>path</code>: A string specifying the path to the file.</li>
<li><code>url</code>: A string specifying the url of the file to put.</li>
<li><code>append</code>: An optional bool, if true the data is appended to the file,
if it already exists.</li>
<li><code>delimiter</code>: An optional int. causes data to be broken up into
separate files by the delimiter. e.g. if you used
<code>Delimiter.CSV.value</code>, a separate PFS file will be created for each
row in the input CSV file, rather than one large CSV file.</li>
<li><code>recursive</code>: allow for recursive scraping of some types URLs, for
example on s3:// URLs.</li>
<li><code>target_file_datums</code>: An optional int. Specifies the target number of
datums in each written file. It may be lower if data does not split
evenly, but will never be higher, unless the value is 0.</li>
<li><code>target_file_bytes</code>: An optional int. Specifies the target number of
bytes in each written file, files may have more or fewer bytes than
the target.</li>
<li><code>header_records: An optional int for splitting data when</code>delimiter`
is not <code>NONE</code> (or <code>SQL</code>). It specifies the number of records that are
converted to a header and applied to all file shards.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_file_from_url(
    self,
    path,
    url,
    append=None,
    delimiter=None,
    recursive=None,
    target_file_datums=None,
    target_file_bytes=None,
    header_records=None,
):
    &#34;&#34;&#34;
    Puts a file using the content found at a URL. The URL is sent to the
    server which performs the request.

    Params:

    * `path`: A string specifying the path to the file.
    * `url`: A string specifying the url of the file to put.
    * `append`: An optional bool, if true the data is appended to the file,
    if it already exists.
    * `delimiter`: An optional int. causes data to be broken up into
    separate files by the delimiter. e.g. if you used
    `Delimiter.CSV.value`, a separate PFS file will be created for each
    row in the input CSV file, rather than one large CSV file.
    * `recursive`: allow for recursive scraping of some types URLs, for
    example on s3:// URLs.
    * `target_file_datums`: An optional int. Specifies the target number of
    datums in each written file. It may be lower if data does not split
    evenly, but will never be higher, unless the value is 0.
    * `target_file_bytes`: An optional int. Specifies the target number of
    bytes in each written file, files may have more or fewer bytes than
    the target.
    * `header_records: An optional int for splitting data when `delimiter`
    is not `NONE` (or `SQL`). It specifies the number of records that are
    converted to a header and applied to all file shards.
    &#34;&#34;&#34;
    self._ops.append(
        AtomicModifyFileURLOp(
            self.commit,
            path,
            url,
            append,
            recursive=recursive,
            # delimiter=delimiter,
            # target_file_datums=target_file_datums,
            # target_file_bytes=target_file_bytes,
            # header_records=header_records,
        )
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="python_pachyderm.PFSFile"><code class="flex name class">
<span>class <span class="ident">PFSFile</span></span>
<span>(</span><span>stream)</span>
</code></dt>
<dd>
<div class="desc"><p>The contents of a file stored in PFS. You can treat these as
file-like objects, like so:</p>
<pre><code>source_file = client.get_file(&quot;montage/master&quot;, &quot;/montage.png&quot;)
with open(&quot;montage.png&quot;, &quot;wb&quot;) as dest_file:
    shutil.copyfileobj(source_file, dest_file)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PFSFile:
    &#34;&#34;&#34;
    The contents of a file stored in PFS. You can treat these as
    file-like objects, like so:

    ```
    source_file = client.get_file(&#34;montage/master&#34;, &#34;/montage.png&#34;)
    with open(&#34;montage.png&#34;, &#34;wb&#34;) as dest_file:
        shutil.copyfileobj(source_file, dest_file)
    ```
    &#34;&#34;&#34;

    def __init__(self, stream):
        # Pachyderm&#39;s GetFile API returns its result (which may include several
        # files, e.g. when getting a directory) as a tar stream--untar the
        # response byte stream as we receive it from GetFile.
        f = tarfile.open(fileobj=stream, mode=&#34;r|*&#34;)
        # TODO how to handle multiple files in the tar stream?
        self._file = f.extractfile(f.next())

    def __iter__(self):
        return self

    def __next__(self):
        x = self.read()
        if not x:
            raise StopIteration
        return x

    def read(self, size=-1):
        return self._file.read(size)

    def close(self):
        self._file.close()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="python_pachyderm.PFSFile.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self):
    self._file.close()</code></pre>
</details>
</dd>
<dt id="python_pachyderm.PFSFile.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self, size=-1)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read(self, size=-1):
    return self._file.read(size)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="python_pachyderm.RpcError"><code class="flex name class">
<span>class <span class="ident">RpcError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Raised by the gRPC library to indicate non-OK-status RPC termination.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RpcError(Exception):
    &#34;&#34;&#34;Raised by the gRPC library to indicate non-OK-status RPC termination.&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>grpc.aio._call.AioRpcError</li>
</ul>
</dd>
<dt id="python_pachyderm.SpoutCommit"><code class="flex name class">
<span>class <span class="ident">SpoutCommit</span></span>
<span>(</span><span>pipe, marker_filename=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents a commit on a spout, permitting the addition of files.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SpoutCommit:
    &#34;&#34;&#34;
    Represents a commit on a spout, permitting the addition of files.
    &#34;&#34;&#34;

    def __init__(self, pipe, marker_filename=None):
        self._tarstream = tarfile.open(fileobj=pipe, mode=&#34;w|&#34;, encoding=&#34;utf-8&#34;)
        self.marker_filename = marker_filename

    def close(self):
        &#34;&#34;&#34;Closes the commit&#34;&#34;&#34;
        self._tarstream.close()

    def put_file_from_fileobj(self, path, size, fileobj):
        &#34;&#34;&#34;
        Adds a file to the spout from a file-like object.

        Params:

        * `path`: The path to the file in the spout.
        * `size`: The size of the file.
        * `fileobj`: The file-like object to add.
        &#34;&#34;&#34;

        tar_info = tarfile.TarInfo(path)
        tar_info.size = size
        tar_info.mode = 0o600
        self._tarstream.addfile(tarinfo=tar_info, fileobj=fileobj)

    def put_file_from_bytes(self, path, bytes):
        &#34;&#34;&#34;
        Adds a file to the spout from a bytestring.

        Params:

        * `path`: The path to the file in the spout.
        * `bytes`: The bytestring representing the file contents.
        &#34;&#34;&#34;

        self.put_file_from_fileobj(path, len(bytes), io.BytesIO(bytes))

    def put_marker_from_fileobj(self, size, fileobj):
        &#34;&#34;&#34;
        Writes to the marker file from a file-like object.

        Params:

        * `size`: The size of the file.
        * `fileobj`: The file-like object to add.
        &#34;&#34;&#34;

        if self.marker_filename is None:
            raise Exception(&#34;no marker filename set&#34;)
        self.put_file_from_fileobj(self.marker_filename, size, fileobj)

    def put_marker_from_bytes(self, bytes):
        &#34;&#34;&#34;
        Adds to the marker from a bytestring.

        Params:

        * `bytes`: The bytestring representing the file contents.
        &#34;&#34;&#34;

        if self.marker_filename is None:
            raise Exception(&#34;no marker filename set&#34;)
        self.put_file_from_fileobj(self.marker_filename, len(bytes), io.BytesIO(bytes))</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="python_pachyderm.SpoutCommit.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Closes the commit</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self):
    &#34;&#34;&#34;Closes the commit&#34;&#34;&#34;
    self._tarstream.close()</code></pre>
</details>
</dd>
<dt id="python_pachyderm.SpoutCommit.put_file_from_bytes"><code class="name flex">
<span>def <span class="ident">put_file_from_bytes</span></span>(<span>self, path, bytes)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a file to the spout from a bytestring.</p>
<p>Params:</p>
<ul>
<li><code>path</code>: The path to the file in the spout.</li>
<li><code>bytes</code>: The bytestring representing the file contents.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_file_from_bytes(self, path, bytes):
    &#34;&#34;&#34;
    Adds a file to the spout from a bytestring.

    Params:

    * `path`: The path to the file in the spout.
    * `bytes`: The bytestring representing the file contents.
    &#34;&#34;&#34;

    self.put_file_from_fileobj(path, len(bytes), io.BytesIO(bytes))</code></pre>
</details>
</dd>
<dt id="python_pachyderm.SpoutCommit.put_file_from_fileobj"><code class="name flex">
<span>def <span class="ident">put_file_from_fileobj</span></span>(<span>self, path, size, fileobj)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a file to the spout from a file-like object.</p>
<p>Params:</p>
<ul>
<li><code>path</code>: The path to the file in the spout.</li>
<li><code>size</code>: The size of the file.</li>
<li><code>fileobj</code>: The file-like object to add.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_file_from_fileobj(self, path, size, fileobj):
    &#34;&#34;&#34;
    Adds a file to the spout from a file-like object.

    Params:

    * `path`: The path to the file in the spout.
    * `size`: The size of the file.
    * `fileobj`: The file-like object to add.
    &#34;&#34;&#34;

    tar_info = tarfile.TarInfo(path)
    tar_info.size = size
    tar_info.mode = 0o600
    self._tarstream.addfile(tarinfo=tar_info, fileobj=fileobj)</code></pre>
</details>
</dd>
<dt id="python_pachyderm.SpoutCommit.put_marker_from_bytes"><code class="name flex">
<span>def <span class="ident">put_marker_from_bytes</span></span>(<span>self, bytes)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds to the marker from a bytestring.</p>
<p>Params:</p>
<ul>
<li><code>bytes</code>: The bytestring representing the file contents.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_marker_from_bytes(self, bytes):
    &#34;&#34;&#34;
    Adds to the marker from a bytestring.

    Params:

    * `bytes`: The bytestring representing the file contents.
    &#34;&#34;&#34;

    if self.marker_filename is None:
        raise Exception(&#34;no marker filename set&#34;)
    self.put_file_from_fileobj(self.marker_filename, len(bytes), io.BytesIO(bytes))</code></pre>
</details>
</dd>
<dt id="python_pachyderm.SpoutCommit.put_marker_from_fileobj"><code class="name flex">
<span>def <span class="ident">put_marker_from_fileobj</span></span>(<span>self, size, fileobj)</span>
</code></dt>
<dd>
<div class="desc"><p>Writes to the marker file from a file-like object.</p>
<p>Params:</p>
<ul>
<li><code>size</code>: The size of the file.</li>
<li><code>fileobj</code>: The file-like object to add.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_marker_from_fileobj(self, size, fileobj):
    &#34;&#34;&#34;
    Writes to the marker file from a file-like object.

    Params:

    * `size`: The size of the file.
    * `fileobj`: The file-like object to add.
    &#34;&#34;&#34;

    if self.marker_filename is None:
        raise Exception(&#34;no marker filename set&#34;)
    self.put_file_from_fileobj(self.marker_filename, size, fileobj)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="python_pachyderm.SpoutManager"><code class="flex name class">
<span>class <span class="ident">SpoutManager</span></span>
<span>(</span><span>marker_filename=None, pfs_directory='/pfs')</span>
</code></dt>
<dd>
<div class="desc"><p>A convenience context manager for creating spouts, allowing you to create
spout code like:</p>
<pre><code>spout = SpoutManager()
while True:
    with spout.commit() as commit:
        commit.put_file_from_bytes(&quot;foo&quot;, b&quot;#&quot;)
    time.sleep(1.0)
</code></pre>
<p>Creates a new spout manager.</p>
<p>Params:</p>
<ul>
<li><code>marker_filename</code>: The name of the file for storing markers. If
unspecified, marker-related operations will fail.</li>
<li><code>pfs_directory</code>: The directory for PFS content. Usually this
shouldn't be explicitly specified, unless the spout manager is being
tested outside of a real Pachyderm pipeline.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SpoutManager:
    &#34;&#34;&#34;
    A convenience context manager for creating spouts, allowing you to create
    spout code like:

    ```
    spout = SpoutManager()
    while True:
        with spout.commit() as commit:
            commit.put_file_from_bytes(&#34;foo&#34;, b&#34;#&#34;)
        time.sleep(1.0)
    ```
    &#34;&#34;&#34;

    def __init__(self, marker_filename=None, pfs_directory=&#34;/pfs&#34;):
        &#34;&#34;&#34;
        Creates a new spout manager.

        Params:

        * `marker_filename`: The name of the file for storing markers. If
        unspecified, marker-related operations will fail.
        * `pfs_directory`: The directory for PFS content. Usually this
        shouldn&#39;t be explicitly specified, unless the spout manager is being
        tested outside of a real Pachyderm pipeline.
        &#34;&#34;&#34;

        self.marker_filename = marker_filename
        self.pfs_directory = pfs_directory
        self._pipe = open(os.path.join(self.pfs_directory, &#34;out&#34;), &#34;wb&#34;)
        self._has_open_commit = False

    def close(self):
        self._pipe.close()

    @contextlib.contextmanager
    def marker(self):
        &#34;&#34;&#34;
        Gets the marker file as a context manager.
        &#34;&#34;&#34;

        if self.marker_filename is None:
            raise Exception(&#34;no marker filename set&#34;)
        with open(os.path.join(self.pfs_directory, self.marker_filename), &#34;r&#34;) as f:
            yield f

    @contextlib.contextmanager
    def commit(self):
        &#34;&#34;&#34;
        Opens a commit on the spout. When the context manager exits, any added
        files will be committed.
        &#34;&#34;&#34;
        if self._has_open_commit:
            raise Exception(&#34;spout commit context manager already opened&#34;)
        spout_commit = SpoutCommit(self._pipe, marker_filename=self.marker_filename)
        self._has_open_commit = True
        try:
            yield spout_commit
        finally:
            spout_commit.close()
            self._has_open_commit = False</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="python_pachyderm.SpoutManager.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self):
    self._pipe.close()</code></pre>
</details>
</dd>
<dt id="python_pachyderm.SpoutManager.commit"><code class="name flex">
<span>def <span class="ident">commit</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Opens a commit on the spout. When the context manager exits, any added
files will be committed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@contextlib.contextmanager
def commit(self):
    &#34;&#34;&#34;
    Opens a commit on the spout. When the context manager exits, any added
    files will be committed.
    &#34;&#34;&#34;
    if self._has_open_commit:
        raise Exception(&#34;spout commit context manager already opened&#34;)
    spout_commit = SpoutCommit(self._pipe, marker_filename=self.marker_filename)
    self._has_open_commit = True
    try:
        yield spout_commit
    finally:
        spout_commit.close()
        self._has_open_commit = False</code></pre>
</details>
</dd>
<dt id="python_pachyderm.SpoutManager.marker"><code class="name flex">
<span>def <span class="ident">marker</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the marker file as a context manager.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@contextlib.contextmanager
def marker(self):
    &#34;&#34;&#34;
    Gets the marker file as a context manager.
    &#34;&#34;&#34;

    if self.marker_filename is None:
        raise Exception(&#34;no marker filename set&#34;)
    with open(os.path.join(self.pfs_directory, self.marker_filename), &#34;r&#34;) as f:
        yield f</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="python_pachyderm.client" href="client.html">python_pachyderm.client</a></code></li>
<li><code><a title="python_pachyderm.mixin" href="mixin/index.html">python_pachyderm.mixin</a></code></li>
<li><code><a title="python_pachyderm.service" href="service.html">python_pachyderm.service</a></code></li>
<li><code><a title="python_pachyderm.spout" href="spout.html">python_pachyderm.spout</a></code></li>
<li><code><a title="python_pachyderm.util" href="util.html">python_pachyderm.util</a></code></li>
<li><code><a title="python_pachyderm.version" href="version.html">python_pachyderm.version</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="python_pachyderm.parse_dict_pipeline_spec" href="#python_pachyderm.parse_dict_pipeline_spec">parse_dict_pipeline_spec</a></code></li>
<li><code><a title="python_pachyderm.parse_json_pipeline_spec" href="#python_pachyderm.parse_json_pipeline_spec">parse_json_pipeline_spec</a></code></li>
<li><code><a title="python_pachyderm.put_files" href="#python_pachyderm.put_files">put_files</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="python_pachyderm.BadClusterDeploymentID" href="#python_pachyderm.BadClusterDeploymentID">BadClusterDeploymentID</a></code></h4>
</li>
<li>
<h4><code><a title="python_pachyderm.Client" href="#python_pachyderm.Client">Client</a></code></h4>
<ul class="">
<li><code><a title="python_pachyderm.Client.auth_token" href="#python_pachyderm.Client.auth_token">auth_token</a></code></li>
<li><code><a title="python_pachyderm.Client.new_from_config" href="#python_pachyderm.Client.new_from_config">new_from_config</a></code></li>
<li><code><a title="python_pachyderm.Client.new_from_pachd_address" href="#python_pachyderm.Client.new_from_pachd_address">new_from_pachd_address</a></code></li>
<li><code><a title="python_pachyderm.Client.new_in_cluster" href="#python_pachyderm.Client.new_in_cluster">new_in_cluster</a></code></li>
<li><code><a title="python_pachyderm.Client.transaction_id" href="#python_pachyderm.Client.transaction_id">transaction_id</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="python_pachyderm.ConfigError" href="#python_pachyderm.ConfigError">ConfigError</a></code></h4>
</li>
<li>
<h4><code><a title="python_pachyderm.ModifyFileClient" href="#python_pachyderm.ModifyFileClient">ModifyFileClient</a></code></h4>
<ul class="">
<li><code><a title="python_pachyderm.ModifyFileClient.copy_file" href="#python_pachyderm.ModifyFileClient.copy_file">copy_file</a></code></li>
<li><code><a title="python_pachyderm.ModifyFileClient.delete_file" href="#python_pachyderm.ModifyFileClient.delete_file">delete_file</a></code></li>
<li><code><a title="python_pachyderm.ModifyFileClient.put_file_from_bytes" href="#python_pachyderm.ModifyFileClient.put_file_from_bytes">put_file_from_bytes</a></code></li>
<li><code><a title="python_pachyderm.ModifyFileClient.put_file_from_fileobj" href="#python_pachyderm.ModifyFileClient.put_file_from_fileobj">put_file_from_fileobj</a></code></li>
<li><code><a title="python_pachyderm.ModifyFileClient.put_file_from_filepath" href="#python_pachyderm.ModifyFileClient.put_file_from_filepath">put_file_from_filepath</a></code></li>
<li><code><a title="python_pachyderm.ModifyFileClient.put_file_from_url" href="#python_pachyderm.ModifyFileClient.put_file_from_url">put_file_from_url</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="python_pachyderm.PFSFile" href="#python_pachyderm.PFSFile">PFSFile</a></code></h4>
<ul class="">
<li><code><a title="python_pachyderm.PFSFile.close" href="#python_pachyderm.PFSFile.close">close</a></code></li>
<li><code><a title="python_pachyderm.PFSFile.read" href="#python_pachyderm.PFSFile.read">read</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="python_pachyderm.RpcError" href="#python_pachyderm.RpcError">RpcError</a></code></h4>
</li>
<li>
<h4><code><a title="python_pachyderm.SpoutCommit" href="#python_pachyderm.SpoutCommit">SpoutCommit</a></code></h4>
<ul class="">
<li><code><a title="python_pachyderm.SpoutCommit.close" href="#python_pachyderm.SpoutCommit.close">close</a></code></li>
<li><code><a title="python_pachyderm.SpoutCommit.put_file_from_bytes" href="#python_pachyderm.SpoutCommit.put_file_from_bytes">put_file_from_bytes</a></code></li>
<li><code><a title="python_pachyderm.SpoutCommit.put_file_from_fileobj" href="#python_pachyderm.SpoutCommit.put_file_from_fileobj">put_file_from_fileobj</a></code></li>
<li><code><a title="python_pachyderm.SpoutCommit.put_marker_from_bytes" href="#python_pachyderm.SpoutCommit.put_marker_from_bytes">put_marker_from_bytes</a></code></li>
<li><code><a title="python_pachyderm.SpoutCommit.put_marker_from_fileobj" href="#python_pachyderm.SpoutCommit.put_marker_from_fileobj">put_marker_from_fileobj</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="python_pachyderm.SpoutManager" href="#python_pachyderm.SpoutManager">SpoutManager</a></code></h4>
<ul class="">
<li><code><a title="python_pachyderm.SpoutManager.close" href="#python_pachyderm.SpoutManager.close">close</a></code></li>
<li><code><a title="python_pachyderm.SpoutManager.commit" href="#python_pachyderm.SpoutManager.commit">commit</a></code></li>
<li><code><a title="python_pachyderm.SpoutManager.marker" href="#python_pachyderm.SpoutManager.marker">marker</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>